---
title: "Simulations addressing the use of correlated observations in FGRS analyses"
author: "Morten Krebs"
date: "9/26/2021"
output: 
    html_document:
        theme: flatly
        toc: yes
vignette: >
    %\VignetteIndexEntry{PAFGRS Vignette}
    %\VignetteEngine{knitr::rmarkdown}
    %\usepackage[utf8]{inputenc}
    %\SweaveUTF8

---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Question 
FGRS summarizes genetic liability a disease given disease status of family members. 
Here we assess how the correlation between estimated liabilities and true liabilities are affected by correlated observations.  

## Simulated Data

### Pedigree
We start with a pedigree that looks like this:
```{r , include=F}
library(FamAgg)
library(ggplot2)

data("minnbreast")
# we get a pedigree of 28 people:
ped <- minnbreast[minnbreast$famid==600,]

ped <- ped[c(which(ped$id==25932),which(ped$id!=25932)),] 
ped <-ped[!ped$id %in% 25934:25936,]

fatherid = ped[ped[,"id"] %in% ped[1,"fatherid"],"id"]
motherid = ped[ped[,"id"] %in% ped[1,"fatherid"],"id"]
sib_id = unique(c(ped[ped[,"fatherid"] %in% ped[1,"fatherid"],"id"], ped[ped[,"motherid"] %in% ped[1,"motherid"],"id"]))
sib_id <- sib_id[!sib_id ==25932]

r <- kinship2::kinship(ped$id, dadid =ped$fatherid ,momid =ped$motherid)*2
depth<- kinship2::kindepth(kinship2::pedigree(ped$id, dadid =ped$fatherid ,momid =ped$motherid,sex = ped$sex),align = T)

gen_back = abs(depth-depth[1])

```

```{r ,echo=F}
plot(kinship2::pedigree(ped$id, dadid =ped$fatherid ,momid =ped$motherid,sex = ped$sex))
```

### Covariance in liability
From this pedigree we specify a covariance matrix assuming a heritability ($h^2$): 

E.g. :
```{r, echo=F}
h2 = .5

#given the following phenotypic cov matrix:
covmatrix= r*h2
diag(covmatrix) <- 1
#covmatrix[1,1] = h2

```

```{r}
covmatrix[1:5,1:5]
```


### Disease status in relatives
We draw liabilities from multivarite normal distribution. We the draw $N$ probands with accompanying relatives, and turn the liabilities into disease status be a threshold function, given the prevalence. 

```{r,, include=F}
prev= .2 #
thr= qnorm(1-prev)  
  

N=1000 #Number of probands 

ped$age <- sapply(gen_back,function(x) if(x>1) runif(1,60,100) else if(x==1) runif(1,40,70) else
    runif(1,10,40))

# age of onset curve :
aoo <- function(age) { 
  pr <- age/65
  pr[pr>1] <- 1
  pr}  


# Simulator:   
sim <- function(N,covmatrix,thr,aoo){
  # draw from mvnorm distribution:
  df <- MASS::mvrnorm(N,mu =rep(0,nrow(covmatrix)),covmatrix)
    
  # introduce varying family structure:
  #df[sample((N+1):(N*nrow(covmatrix)),N*nrow(covmatrix)/2,replace = F)] <- NA
  df <- data.frame(df) 
  colnames(df) <- paste0("z",1:nrow(covmatrix))
  
  age <- t(matrix(ped$age[-1],nrow(covmatrix)-1,N))
  
  # expressed proportion of lifetime risk: 
  prop_risk <- apply(age,2,aoo) 
  
  # threshold
  status <- apply(df[,2:nrow(covmatrix)], 2, function(x) x>thr)
  suppressWarnings(status[which(status)] <-  sapply(prop_risk[which(status)], function(x) rbinom(1,1,prob = x)))
  # Dataframe with true liabilities, status and age:
  cbind(df,status=status,age=age)
}


```

# Esimated liabilities:

PAFGRS is used to estimate the liability given the pedigree.
```{r, include=F}

## FGRS parameters 

# aoo <- function(age) { 
#   pr <- age/65
#   pr[pr>1] <- 1
#   pr}  

aoo <- function(age) { # congenital trait ==> no censoring 
  pr <- rep(1,length(age))
  pr}


rel_mat <- r 
env_cor=1

```


## Correlated observations, no shared evironment: 

```{r,cache=T}
library(PAFGRS)
n_sim=1000

out <- data.frame(t(sapply(1:n_sim, function(i){ 
  
  h2 = i/n_sim
  #h2=.5
    
  #given the following phenotypic cov matrix:
  rt <- r 
  rt[1,paste(sib_id)] <- rt[paste(sib_id),1] <- rt[paste(sib_id),paste(sib_id)] <- 1 # make triplets 
  covmatrix= rt*h2
  
  
  diag(covmatrix) <- 1

  df <- sim(N,covmatrix,thr,aoo)


  #fgrs <- FGRS(df = df, rel_mat = rel_mat,prev = prev,aoo = aoo,env_cor = 1,ped=ped) 
  n_fam <- ncol(rel_mat)
  sib_cols <- which(colnames(rel_mat) %in% sib_id)
  fgrs_rel <- FGRS(df = df[,-c(sib_cols+1,n_fam+sib_cols,2*n_fam+sib_cols-1)], rel_mat = rel_mat[-sib_cols,-sib_cols],prev = prev,aoo = aoo,env_cor = 1,ped=ped[-sib_cols,]) 
  
  
  #plot(fgrs,fgrs_rel)
  
  
  ss <- c(which(!is.na(df[,sib_cols[1]]))[1:300])
  
  #if(length(ss)>500) ss <- ss[1:500]
  ss <- c(ss,N+ss,2*N+ss)
  
  
  ct <-cor.test(c(fgrs_rel)[1:length(ss)],c(df$z1)[1:length(ss)])
  
  ct_rel <-cor.test(c(fgrs_rel,fgrs_rel,fgrs_rel)[ss],c(df$z1,df[,sib_cols[1]],df[,sib_cols[2]])[ss])
  
  lr <-glm(c(df$z1)[1:length(ss)]>thr~c(fgrs_rel)[1:length(ss)],family = "binomial")
  R2=var(lr$linear.predictors)/(var(lr$linear.predictors)+pi^2/3)
  z=summary(lr)$coefficient[2,"z value"]
  
  lr_rel <-glm(c(df$z1,df[,sib_cols[1]],df[,sib_cols[2]])[ss]>thr~c(fgrs_rel,fgrs_rel,fgrs_rel)[ss],family = "binomial")
  R2_rel=var(lr_rel$linear.predictors)/(var(lr_rel$linear.predictors)+pi^2/3)
  z_rel=summary(lr_rel)$coefficient[2,"z value"]
  
  
  
  c(ct$estimate,ct$statistic,ct_rel$estimate,ct_rel$statistic,R2=R2,z=z,R2_rel=R2_rel,z_rel=z_rel)#,cov(c(fgrs_rel),c(df$z1)),cov(c(fgrs_rel,fgrs_rel)[ss],c(df$z1,df[,sib_cols[1]])[ss]),var(c(df$z1,df[,sib_cols[1]])[ss]),var(df$z1))
})))

# Correlation between true and estimated liability:
ggplot(data = data.frame(h2=rep(1:n_sim/n_sim,2),type=c(rep("unrelated",n_sim),rep("300 triplets",n_sim)),cor= c(out$cor,out$cor.1)),aes(h2,cor,col=type))+geom_point()+geom_smooth(method="lm")


# Squared residuals
ggplot(data = data.frame(h2=rep(1:n_sim/n_sim,2),type=c(rep("unrelated",n_sim),rep("sibpairs",n_sim)),cor= c(out$cor,out$cor.1)),aes(h2,resid(lm(cor~h2))^2,col=type))+geom_point()+geom_smooth(method = "lm")


# R^2 in logistic regression:
ggplot(data = data.frame(h2=rep(1:n_sim/n_sim,2),type=c(rep("unrelated",n_sim),rep("300 triplets",n_sim)),cor= c(out$R2,out$R2_rel)),aes(h2,cor,col=type))+geom_point()+geom_smooth()

# Wald in logistic regression:
ggplot(data = data.frame(h2=rep(1:n_sim/n_sim,2),type=c(rep("unrelated",n_sim),rep("300 triplets",n_sim)),cor= c(out$z,out$z_rel)),aes(h2,cor,col=type))+geom_point()+geom_smooth()

```


## Correlated observations and shared evironment: 

```{r, cache=T}
N=1000

n_sim=1000

out <- data.frame(t(sapply(1:n_sim, function(i){ 
  
  h2 = .5*i/n_sim
  #h2=.5
    
  #given the following phenotypic cov matrix:
  rt <- r 
  rt[1,paste(sib_id)] <- rt[paste(sib_id),1] <- rt[paste(sib_id),paste(sib_id)] <- 1 # make triplets 
  covmatrix= rt*h2
  
  covmatrix2=covmatrix+.25
  covmatrix2[covmatrix2>1] <- 1
  diag(covmatrix) <- diag(covmatrix2) <- 1
  
    df <- sim(N,covmatrix2,thr,aoo)
  
  
  #fgrs <- FGRS(df = df, rel_mat = rel_mat,prev = prev,aoo = aoo,env_cor = 1,ped=ped) 
  n_fam <- ncol(rel_mat)
  sib_cols <- which(colnames(rel_mat) %in% sib_id)
  fgrs_rel <- FGRS(df = df[,-c(sib_cols+1,n_fam+sib_cols,2*n_fam+sib_cols-1)], rel_mat = rel_mat[-sib_cols,-sib_cols],prev = prev,aoo = aoo,env_cor = 1,ped=ped[-sib_cols,]) 
  
  
  #plot(fgrs,fgrs_rel)
  
  
  ss <- c(which(!is.na(df[,sib_cols[1]]))[1:(N*.3)])
  
  #if(length(ss)>500) ss <- ss[1:500]
  ss <- c(ss,N+ss,2*N+ss)
  
  
  ct <-cor.test(c(fgrs_rel)[1:length(ss)],c(df$z1)[1:length(ss)])
  
  ct_rel <-cor.test(c(fgrs_rel,fgrs_rel,fgrs_rel)[ss],c(df$z1,df[,sib_cols[1]],df[,sib_cols[2]])[ss])
  
  lr <-glm(c(df$z1)[1:length(ss)]>thr~c(fgrs_rel)[1:length(ss)],family = "binomial")
  R2=var(lr$linear.predictors)/(var(lr$linear.predictors)+pi^2/3)
  z=summary(lr)$coefficient[2,"z value"]
  
  lr_rel <-glm(c(df$z1,df[,sib_cols[1]],df[,sib_cols[2]])[ss]>thr~c(fgrs_rel,fgrs_rel,fgrs_rel)[ss],family = "binomial")
  R2_rel=var(lr_rel$linear.predictors)/(var(lr_rel$linear.predictors)+pi^2/3)
  z_rel=summary(lr_rel)$coefficient[2,"z value"]
  
  
  
  c(ct$estimate,ct$statistic,ct_rel$estimate,ct_rel$statistic,R2=R2,z=z,R2_rel=R2_rel,z_rel=z_rel)#,cov(c(fgrs_rel),c(df$z1)),cov(c(fgrs_rel,fgrs_rel)[ss],c(df$z1,df[,sib_cols[1]])[ss]),var(c(df$z1,df[,sib_cols[1]])[ss]),var(df$z1))
})))

# Correlation between true and estimated liability:
ggplot(data = data.frame(h2=rep(1:n_sim/n_sim,2),type=c(rep("unrelated",n_sim),rep("300 triplets",n_sim)),cor= c(out$cor,out$cor.1)),aes(h2,cor,col=type))+geom_point()+geom_smooth(method="lm")


# Squared residuals
ggplot(data = data.frame(h2=rep(1:n_sim/n_sim,2),type=c(rep("unrelated",n_sim),rep("sibpairs",n_sim)),cor= c(out$cor,out$cor.1)),aes(h2,resid(lm(cor~h2))^2,col=type))+geom_point()+geom_smooth(method = "lm")


# R^2 in logistic regression:
ggplot(data = data.frame(h2=.5*rep(1:n_sim/n_sim,2),type=c(rep("900 unrelated",n_sim),rep("300 triplets",n_sim)),R2= c(out$R2,out$R2_rel)),aes(h2,R2,col=type))+geom_point()+geom_smooth()

# Wald in logistic regression:
ggplot(data = data.frame(h2=rep(1:n_sim/n_sim,2),type=c(rep("unrelated",n_sim),rep("300 triplets",n_sim)),cor= c(out$z,out$z_rel)),aes(h2,cor,col=type))+geom_point()+geom_smooth()

```

